"         _                                         
"        (_)                                        
"  __   ___ _ __ ___  _ __ ___                      
"  \ \ / / | '_ ` _ \| '__/ __|                     
"   \ V /| | | | | | | | | (__                      
"  (_)_/ |_|_| |_| |_|_|  \___|                     
"                     _     _ _             _       
"                    | |   (_) |           (_)      
"  __      _____  ___| |__  _| | __ _ _ __  _ _ __  
"  \ \ /\ / / _ \/ __| '_ \| | |/ _` | '_ \| | '_ \ 
"   \ V  V / (_) \__ \ | | | | | (_| | |_) | | | | |
"    \_/\_/ \___/|___/_| |_|_|_|\__,_| .__/|_|_| |_|
"                                    | |            
"                                    |_|            
"
" ASCII art generated on
" http://www.patorjk.com/software/taag/#p=display&h=2&v=1&c=bash&f=Doom&t=.vimrc%0Awoshilapin

" Vim configuration file
" Language: Vim (ft=vim)
" Last Change: Mon 22 Oct 2012 (09:35)
" Version: 0.1
" Maintainer: woshilapin <woshilapin@gmail.com>
" License: This file is placed in the public domain.

"" Activate the pathogen plugin to rule all other plugin
set nocompatible
runtime bundle/pathogen/autoload/pathogen.vim
execute pathogen#infect()
execute pathogen#helptags()

"" Activer les différents greffons
" Autoriser le chargement des greffons généraux
set loadplugins
" Activer la coloration syntaxique
syntax on
" Activer la détection des types de fichiers
filetype on
" Activer les greffons pour les types de fichier
filetype plugin on
" Activer les fichiers d'indentation
filetype indent on

"""" MAPPAGES
"" Les préfixes de mappages
" Définition de la chaîne pour les mappages locaux
let mapleader="@"
" Définition de la chaîne pour les mappages locaux
let maplocalleader="="

"" Définition de mappages
" Afficher l'explorateur
nmap <Leader>me :NERDTreeToggle<Enter>R
" Afficher l'explorateur en précisant le répertoire racine
nmap <Leader>mE :NERDTree 
" Afficher l'explorateur
nmap <Leader>mu :UndotreeToggle<Enter>

"""" OPTIONS
" Set the mouse abilities in the terminal
" set mouse=a
" if &term == "rxvt-unicode"
" 	set ttymouse="urxvt"
" endif

" Set the clipboard option to copy each selected and yanked text into the 
" clipboard of the system
set clipboard=unnamedplus,unnamed,autoselectplus,autoselect,html
" Replace all occurences in a line by default
set gdefault
" Automatically read files when they have been changed on disk outside of Vim
set autoread
" Autosave the file on the call of some command (':quit', ':edit', ...)
set autowriteall
" normally don't automatically format `text' as it is typed, IE only do this
" with comments, at 79 characters:
set formatoptions=
set textwidth=80
" Have % bounce between angled brackets, as well as the other kinds:
set matchpairs=(:),{:},[:],<:>
" Allow <BkSpc> to delete line breaks, beyond the start of the current insertion, and over indentations:
set backspace=eol,start,indent
"" DISPLAY
" Print the line numbers
set number
" Print line numbers relative to the current edited line
set relativenumber
" Don't make it look like there are line breaks where there aren't:
set wrap
" Display long lines on 2 lines
set linebreak
" Define the beginning of a breaking line
set showbreak=>
" Display the current mode and partially-typed commands in the status line:
set showmode
" Display the status line
set laststatus=2
" Display the current typing command
set showcmd
" Print the current line and column number
set ruler
" when using list, keep tabs at their full width and display `arrows':
set listchars=eol:$,tab:>-,trail:=,extends:>,precedes:<
"" INDENTATION
" use indents of 2 spaces, and have them copied down lines:
" Size of the tabulation display
set tabstop=4
" Number of spaces for a tabulation (0: desactivated)
set softtabstop=0
" Value used to indent ('=', '>>', '<<', ...)
set shiftwidth=4
" Make indentation a multiple of 'shiftwidth' value
set shiftround
" Do not replace tabulation with a number of spaces
set noexpandtab
" Do an automatic indentation if possible
set autoindent
"" ENCODING
" Encoding for the file
set fileencoding=utf8
" What encoding is used to print the file
set printencoding=utf8
" Default encoding
set encoding=utf8
" Height of the help 'split' window
set helpheight=20
" Activate the detection of the filetype
filetype on
" Activate the coloration of the file depending on filetype
syntax on
"" SEARCH
" Highlight the search pattern
set hlsearch
" Move the cursor in the file during the search
set incsearch
" make searches case-insensitive, unless they contain upper-case letters:
set ignorecase
" Ignore 'ignorecase' in case search pattern use cap letter
set smartcase
"" COMPLETION
" Auto-completion list priorities
set complete=.,w,b,t,k,s
set infercase

"""" COLORS
" Change the panel of colors to 256 (instead of 8)
set t_Co=256
set colorcolumn=81
colorscheme base16-default-dark
highlight NonText ctermfg=DarkGray
highlight SpecialKey ctermfg=DarkGray

" To highlight the column and line of the current cursor position
highlight CursorLine term=reverse cterm=reverse
highlight CursorColumn term=reverse cterm=reverse
nmap <Leader>h :set cursorline! cursorcolumn!<bar>set cursorline? cursorcolumn?<CR><CR>

" Have fifty lines of command-line (etc) history:
set history=50
" Remember all of these between sessions, but only 10 search terms; also
" remember info for 10 files, but never any on removable disks, don't remember
" marks in files, don't rehighlight old search patterns, and only save up to
" 100 lines of registers; including @10 in there should restrict input buffer
" but it causes an error for me:
set viminfo=!,%,/256,'256,r/mnt/zip,r/mnt/floppy,f0,h,\"100

" * Keystrokes -- Moving Around

" Moving in an help file
nmap <Leader>n /\%(\|\zs[A-Za-z0-9_.:<>-]\{-}\ze\|\\|'\zs[A-Za-z0-9_]\{-}\ze'\)<Enter>:nohl<Enter>
nmap <Leader>N ?\%(\|\zs[A-Za-z0-9_.:<>-]\{-}\ze\|\\|'\zs[A-Za-z0-9_]\{-}\ze'\)<Enter>:nohl<Enter>

" Page down with <Space> (like in `Lynx', `Mutt', `Pine', `Netscape Navigator',
" `SLRN', `Less', and `More'); page up with - (like in `Lynx', `Mutt', `Pine'),
" or <BkSpc> (like in `Netscape Navigator'):
nmap <Space> 3<C-E>
nmap <S-Space> 3<C-Y>

" Use <F2> to cycle through split windows (and <Shift>+<F2> to cycle backwards,
" where possible):
nnoremap <F2> <C-W>w
nnoremap <S-F2> <C-W>W

" Have <F1> prompt for a help topic, rather than displaying the introduction
" page, and have it do this from any mode:
nnoremap <F1> :help<Space>
vmap <F1> <C-C><F1>
omap <F1> <C-C><F1>
map! <F1> <C-C><F1>

" To 'make' a project in one touch!
noremap <F5> :make<Enter>

" Have the usual indentation keystrokes still work in visual mode:
vnoremap <C-T> >
vnoremap <C-D> <LT>

" Have Y behave analogously to D and C rather than to dd and cc (which is already done by yy):
nnoremap Y y$

" To go and replace the following tag '<+TAG+>'
noremap <Leader>j /<+.\{-}+>/s<CR>:silent! foldopen!<CR>v/<+.\{-}+>/e<CR><C-g>
noremap <Leader>k ?<+.\{-}+>?e<CR>:silent! foldopen!<CR>v?<+.\{-}+>?s<CR><C-g>
snoremap <Leader>j <Esc>/<+.\{-}+>/s<CR>:silent! foldopen!<CR>v/<+.\{-}+>/e<CR><C-g>
snoremap <Leader>k <Esc>?<+.\{-}+>?e<CR>:silent! foldopen!<CR>v?<+.\{-}+>?s<CR><C-g>
inoremap <Leader>j <Esc>/<+.\{-}+>/s<CR>:silent! foldopen!<CR>v/<+.\{-}+>/e<CR><C-g>
inoremap <Leader>k <Esc>?<+.\{-}+>?e<CR>:silent! foldopen!<CR>v?<+.\{-}+>?s<CR><C-g>

"" About easytags
" Change the default name of the tag file
let g:easytags_file='tags'
" Disable the automatic update of tags file
let g:easytags_on_cursorhold=0

"" Edition of PO files
let g:po_translator="woshilapin <woshilapin@gmail.com>"
let g:po_lang_team="French"

"" About Git
" The message when there is no Git repository ('.git')on the current directory
let g:git_branch_status_nogit="nothing"
" Check the current branch if it's the same branch where the file was loaded, before saving the file.
let g:git_branch_check_write=1

" To have folding on XML files
let g:xml_syntax_folding=1
au FileType xml setlocal foldmethod=syntax

" Improve the autoread functionality
if has("autocmd")
	autocmd FocusGained,BufEnter,CursorHold,CursorHoldI * checktime
	autocmd FileChangedShellPost *
				\ echohl WarningMsg | echo "File changed on disk. Buffer reloaded." | echohl None
endif

" To come back to the last edited line
if has("autocmd")
	autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
				\| exe "normal! g'\"" | endif
endif
" The previous option should not happen when editing a commit of Git (always on top of the file)
if has("autocmd")
	augroup git
		autocmd BufReadPost COMMIT_EDITMSG normal! gg
		autocmd BufReadPost COMMIT_EDITMSG startinsert
	augroup END
endif

" Look for the first empty line to begin to write
if has("autocmd")
	augroup mutt
		" Go to the top of the file
		autocmd BufReadPost mutt-* normal! gg
		" Find the first empty line
		autocmd BufReadPost mutt-* execute search('^\s*$')
		" Go into insert mode
		autocmd BufReadPost mutt-* startinsert
	augroup END
endif

function s:java_test()
	map <F5> <Esc>:wa<Enter>:!javac %<Enter>
	let package_line_number=search("^package.*;", 'n')
	let package_line=getline(package_line_number)
	let package=substitute(package_line, "package\\s*\\(\\<.*\\);", "\\1", "")
	let package_path=substitute(package, "\\.", "\\/", "")
	let file_dir=expand("%:p:h")
	let file_classpath=substitute(file_dir, package_path, "", "")
	let classpath="\"/usr/share/java/junit4.jar:".file_classpath."\""
	let junit_runner="org.junit.runner.JUnitCore"
	let file_class=package.".".expand("%:r")
	let test_map="map <F7> <Esc>:!java -cp "
	let test_map=test_map.classpath." "
	let test_map=test_map.junit_runner." "
	let test_map=test_map.file_class."<Enter>"
	exec test_map
endfunction

if has("autocmd")
	autocmd BufReadPost *Test.java call <SID>java_test()
endif

" Change the look of the cursor when changing the mode (insert or normal)
let &t_SI = "\<Esc>]50;CursorShape=1\x7"
let &t_EI = "\<Esc>]50;CursorShape=0\x7"

" To paste without setting 'paste' (it is automatic)
if &term =~ "xterm.*"
    let &t_ti = &t_ti . "\e[?2004h"
    let &t_te = "\e[?2004l" . &t_te
    function XTermPasteBegin(ret)
        set pastetoggle=<Esc>[201~
        set paste
        return a:ret
    endfunction
    map <expr> <Esc>[200~ XTermPasteBegin("i")
    imap <expr> <Esc>[200~ XTermPasteBegin("")
endif
" To load the Cscope database
if has("cscope")
	let s:cscopeprg_list =
				\ "/usr/bin/cscope" .
				\ "/opt/local/bin/cscope"
	for s:entry in split(s:cscopeprg_list, " ")
		if filereadable(s:entry)
			set cscopeprg=s:entry
			break
		endif
	endfor
	set cscopetagorder=0
	set cscopetag
	set cscopequickfix="s+,g+,d+,c+,t+,e+,f+,i+"
	set cscopepathcomp=1
	set nocscopeverbose
	set cscopeverbose
	let g:autotags_cscope_file_extensions = ".cpp .cc .cxx .m .hpp .hh .h .hxx .c .idl .java"
	let s:autotags_ctags_global_include = 
				\ "/usr/include/" .
				\ " /usr/include/sys/" .
				\ " /usr/include/net/" .
				\ " /usr/include/bits/" .
				\ " /usr/include/arpa/" .
				\ " /usr/include/asm/" .
				\ " /usr/include/asm-generic/" .
				\ " /usr/include/linux/" .
				\ " /opt/local/include/" .
				\ " /opt/local/include/GL/" .
				\ " /opt/local/include/gcc47/c++/"
	let g:autotags_ctags_global_include = ""
    for s:entry in split(s:autotags_ctags_global_include, " ")
		if isdirectory(s:entry)
			let g:autotags_ctags_global_include = 
						\ g:autotags_ctags_global_include .
						\ " " . s:entry . "*"
		endif
	endfor
	noremap <Leader>tu :call AutotagsUpdate()<Enter>
	noremap <Leader>ta :call AutotagsAdd()<Enter>
	noremap <Leader>ts :cscope find s <C-R>=expand("<cword>")<CR><CR>
	noremap <Leader>tg :cscope find g <C-R>=expand("<cword>")<CR><CR>
	noremap <Leader>td :cscope find d <C-R>=expand("<cword>")<CR><CR>
	noremap <Leader>tc :cscope find c <C-R>=expand("<cword>")<CR><CR>
	noremap <Leader>tt :cscope find t <C-R>=expand("<cword>")<CR><CR>
	noremap <Leader>te :cscope find e <C-R>=expand("<cword>")<CR><CR>
	noremap <Leader>tf :cscope find f <C-R>=expand("<cfile>")<CR><CR>
	noremap <Leader>ti :cscope find i ^<C-R>=expand("<cfile>")<CR>$<CR>
	noremap <Leader>th :cscope help<Enter>
endif

" When forgot to open the file in root
command Wroot silent execute 'write !sudo tee ' . shellescape(@%, 1) . ' >/dev/null'

" For persistent undo (write in a file)
if exists("+undodir")
	set undodir=".undo"
	set undofile
endif
if exists("*rundo")
	au BufReadPost * call ReadUndo()
	func ReadUndo()
		let undodir=".undo/"
		let undo_filename = undodir . expand('%:t')
		if filereadable(undo_filename)
			execute 'rundo ' . undo_filename
		endif
	endfunc
endif
if exists("*rundo")
	au BufWritePost * call WriteUndo()
	func WriteUndo()
		let undodir=".undo/"
		let undo_filename = undodir . expand('%:t')
		if !isdirectory(undodir)
			call mkdir(undodir)
		endif
		execute 'wundo ' . undo_filename
	endfunc
endif

" Configuration of the vim-signature plugin
let g:SignaturePurgeConfirmation=1
if !hasmapto( '<Plug>SIG_NextLineByAlpha'  ) | nmap <buffer> ') <Plug>SIG_NextLineByAlpha| endif
if !hasmapto( '<Plug>SIG_PrevLineByAlpha'  ) | nmap <buffer> '( <Plug>SIG_PrevLineByAlpha| endif
if !hasmapto( '<Plug>SIG_NextSpotByAlpha'  ) | nmap <buffer> `) <Plug>SIG_NextSpotByAlpha| endif
if !hasmapto( '<Plug>SIG_PrevSpotByAlpha'  ) | nmap <buffer> `( <Plug>SIG_PrevSpotByAlpha| endif
if !hasmapto( '<Plug>SIG_NextLineByPos'    ) | nmap <buffer> '] <Plug>SIG_NextLineByPos| endif
if !hasmapto( '<Plug>SIG_PrevLineByPos'    ) | nmap <buffer> '[ <Plug>SIG_PrevLineByPos| endif
if !hasmapto( '<Plug>SIG_NextSpotByPos'    ) | nmap <buffer> `] <Plug>SIG_NextSpotByPos| endif
if !hasmapto( '<Plug>SIG_PrevSpotByPos'    ) | nmap <buffer> `[ <Plug>SIG_PrevSpotByPos| endif
if !hasmapto( '<Plug>SIG_NextMarkerByType' ) | nmap <buffer> '} <Plug>SIG_NextMarkerByType| endif
if !hasmapto( '<Plug>SIG_PrevMarkerByType' ) | nmap <buffer> '{ <Plug>SIG_PrevMarkerByType| endif

" Read a '.vimrc' in the current directory of edition or in the local 
" directory of the edited file
let s:home_directory = expand("~")
let s:vim_directory = s:home_directory . "/.vim"
let s:conf_filename = ".vimrc"
let s:current_directory = getcwd()
let s:source_directory = expand("%:p:h")
let s:current_conf_filename = "'" . s:current_directory . "/" . s:conf_filename . "'"
let s:source_conf_filename = "'" . s:source_directory . "/" . s:conf_filename . "'"
" Do not forget to avoid loading the '.vimrc' in the HOME directory and in the 
" '~/.vim/' directory to prevent recursive loading of this file.
if filereadable(s:current_conf_filename) && s:current_directory != s:home_directory && s:current_directory != s:vim_directory
	execute "source " . substitute(s:current_conf_filename, " ", "\\ ", "g")
endif
" To read local directory '.vimrc' configuration file from the directory of the opened file
if filereadable(s:source_conf_filename) && s:source_directory != s:home_directory && s:source_directory != s:vim_directory
	execute "source " . substitute(s:source_conf_filename, " ", "\\ ", "g")
endif

" Configuration of Syntastic plugin
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
" Make quickfix window of syntastic smaller if possible
function! SyntasticCheckHook(errors)
	if !empty(a:errors)
		let g:syntastic_loc_list_height = min([len(a:errors), 10])
	endif
endfunction

" Configuration of Powerline plugin
if has('python')
	python from powerline.vim import setup as powerline_setup
	python powerline_setup()
	python del powerline_setup
	set runtimepath+=/home/woshilapin/.virtualenvs/powerline-status/lib/python3.6/site-packages/powerline/bindings/vim
	set laststatus=2 " Always display the statusline in all windows
	set showtabline=2 " Always display the tabline, even if there is only one tab
	set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
endif

" Configuration of CtrlP plugin
let g:ctrlp_map = '<C-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_root_markers = ['pom.xml', '.p4ignore']
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']

" Configuration for 'vim-javascript' plugin
let g:javascript_plugin_jsdoc = 1

" Configuration for 'vim-jsdoc' plugin
let g:jsdoc_allow_input_prompt = 1
let g:jsdoc_input_description = 1
let g:jsdoc_additional_descriptions = 1
" Look for the main function the cursor is currently in
nmap <silent> <C-l> :set hlsearch!<CR>{/function<CR>:set hlsearch!<CR>:nohlsearch<CR><Plug>(jsdoc)

" vim-lsp
let g:lsp_diagnostics_enabled = 1
let g:lsp_signs_enabled = 1
let g:lsp_diagnostics_echo_cursor = 1
let g:lsp_signs_error = {'text': '✗'}
let g:lsp_signs_warning = {'text': '‼'}
let g:lsp_signs_hint = {'text': '💡'}
let g:lsp_highlights_enabled = 1
let g:lsp_textprop_enabled = 1
let g:lsp_highlight_references_enabled = 1
let g:lsp_preview_keep_focus = 0

let g:lsp_log_verbose = 1
let g:lsp_log_file = expand('/tmp/vim-lsp.log')

" for asyncomplete.vim log
let g:asyncomplete_log_file = expand('/tmp/asyncomplete.log')
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
inoremap <expr> <cr>    pumvisible() ? "\<C-y>" : "\<cr>"

function! s:check_back_space() abort
	let col = col('.') - 1
	return !col || getline('.')[col - 1]  =~ '\s'
endfunction

inoremap <silent><expr> <TAB>
	\ pumvisible() ? "\<C-n>" :
	\ <SID>check_back_space() ? "\<TAB>" :
	\ asyncomplete#force_refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

noremap gd :LspDefinition<Enter>

if has("mac")
	source /usr/local/Cellar/fzf/0.18.0/plugin/fzf.vim
elseif has("unix")
	source /usr/share/doc/fzf/examples/fzf.vim
endif
noremap <C-p> :Files .<Enter>
" End of woshilapin's .vimrc
